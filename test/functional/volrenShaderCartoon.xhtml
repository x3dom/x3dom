<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>

    <!-- Copyright 2012 by John Congote <jcongote@vicomtech.org> -->
  <head>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>

<!-- BEGIN:X3DOM -->
<meta http-equiv="X-UA-Compatible" content="chrome=1,IE=edge" />
<link rel="stylesheet" type="text/css" href="../../src/x3dom.css" />
<script type="text/javascript" src="../../src/lang/Array.js"></script>
<script type="text/javascript" src="../../src/Internals.js"></script>
<script type="text/javascript" src="../../src/debug.js"></script>
<script type="text/javascript" src="../../src/ImageLoadManager.js"></script>
<script type="text/javascript" src="../../src/util/Properties.js"></script>
<script type="text/javascript" src="../../src/util/DoublyLinkedList.js"></script>
<script type="text/javascript" src="../../src/util/EarClipping.js"></script>
<script type="text/javascript" src="../../src/X3DCanvas.js"></script>
<script type="text/javascript" src="../../src/Runtime.js"></script>
<script type="text/javascript" src="../../src/Main.js"></script>
<script type="text/javascript" src="../../src/gfx_webgl.js"></script>
<script type="text/javascript" src="../../src/gfx_flash.js"></script>
<script type="text/javascript" src="../../src/X3DDocument.js"></script>
<script type="text/javascript" src="../../src/MatrixMixer.js"></script>
<script type="text/javascript" src="../../src/Viewarea.js"></script>
<script type="text/javascript" src="../../src/Mesh.js"></script>
<script type="text/javascript" src="../../src/fields.js"></script>
<script type="text/javascript" src="../../src/nodes/NodeNameSpace.js"></script>
<script type="text/javascript" src="../../src/nodes/Core.js"></script>
<script type="text/javascript" src="../../src/nodes/Grouping.js"></script>
<script type="text/javascript" src="../../src/nodes/Bindable.js"></script>
<script type="text/javascript" src="../../src/nodes/Rendering.js"></script>
<script type="text/javascript" src="../../src/nodes/Shape.js"></script>
<script type="text/javascript" src="../../src/nodes/Lighting.js"></script>
<script type="text/javascript" src="../../src/nodes/Followers.js"></script>
<script type="text/javascript" src="../../src/nodes/Interpolation.js"></script>
<script type="text/javascript" src="../../src/nodes/Time.js"></script>
<script type="text/javascript" src="../../src/nodes/Networking.js"></script>
<script type="text/javascript" src="../../src/nodes/EnvironmentalEffects.js"></script>
<script type="text/javascript" src="../../src/nodes/Navigation.js"></script>
<script type="text/javascript" src="../../src/nodes/Text.js"></script>
<script type="text/javascript" src="../../src/nodes/Sound.js"></script>
<script type="text/javascript" src="../../src/nodes/Texturing.js"></script>
<script type="text/javascript" src="../../src/nodes/Shaders.js"></script>
<script type="text/javascript" src="../../src/nodes/Geometry3D.js"></script>
<script type="text/javascript" src="../../src/nodes/Geospatial.js"></script>
<script type="text/javascript" src="../../src/nodes/Geometry2D.js"></script>
<script type="text/javascript" src="../../src/nodes/VolumeRendering.js"></script>
<script type="text/javascript" src="../../src/Docs.js"></script>
<!-- END:X3DOM -->

<!-- BEGIN:TEST -->
<script type="text/javascript" src="media/js/tests.js"></script>
<!-- END:TEST -->

  </head>
  
  <body>

   
<X3D xmlns='http://www.web3d.org/specifications/x3d-namespace' showStat='true' showLog='true' width='500px' height='500px'>
<Scene>
<Group>
 
<Background skyColor='0 0 0'/>
<Viewpoint description='Default' position='0 0 2.5' zNear='0.0001' zFar='100'/>  
<Shape DEF="volume">
<Appearance>
 
<MultiTexture>
<ImageTexture url='media/volume/aorta4096.png' />
<ImageTexture url='media/volume/aorta1_gradientXYZ4096.png' />
</MultiTexture>
  
     <ComposedShader DEF='ComposedShader'>
       <field name='uVolData' type='SFInt32' value='0'/>
       <field name='defaultNormals' type='SFInt32' value='1'/>
       <ShaderPart type='VERTEX'>
       <![CDATA[
uniform mat4 modelViewProjectionMatrix;
uniform mat4 modelViewMatrixInverse;
attribute vec3 position;

mat4 textureMatrix;
mat4 textureMatrixInverse;
       
varying vec3 rayStart;
varying vec3 rayDir;

void main()
{
textureMatrix = mat4(1.000, 0.000, 0.000, 0.500, 0.000, 1.000, 0.000, 0.500, 0.000, 0.000, 1.000, 0.500, 0.000, 0.000, 0.000, 1.000);
textureMatrixInverse = mat4(1.000, 0.000, 0.000, -0.500, 0.000, 1.000, 0.000, -0.500, 0.000, 0.000, 1.000, -0.500, 0.000,  0.000,  0.000,  1.000);
rayStart = (textureMatrix*vec4(position, 1.0)).xyz;
rayDir = rayStart-(textureMatrix*modelViewMatrixInverse*vec4(0.0,0.0,0.0,1.0)).xyz;
gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);
}
       ]]>
       </ShaderPart>
       <ShaderPart type='FRAGMENT'>
       <![CDATA[
#ifdef GL_ES
precision highp float;
#endif

uniform mat4 modelViewMatrix;
uniform mat4 modelViewMatrixInverse;

uniform sampler2D uVolData;
uniform sampler2D defaultNormals;


mat4 textureMatrix;
mat4 textureMatrixInverse;

float rayStep = 0.01;
const float numberOfSlices = 96.0;
const float slicesOverX = 10.0;
const float slicesOverY = 10.0;

varying vec3 rayStart;
varying vec3 rayDir;

// Style Vars
const bool enabled4188f80 = true;
const vec3 parallelColor4188f80 = vec3(0,1,0);
const vec3 orthogonalColor4188f80 = vec3(1,0 ,1);
const int colorSteps4188f80 = 4;



vec4 cTexture3D(sampler2D uData,vec3 volpos)
{
  float s1,s2;
  float dx1,dy1;
  float dx2,dy2;

  vec2 texpos1,texpos2;

  s1 = floor(volpos.z*numberOfSlices);
  s2 = s1+1.0;

  dx1 = fract(s1/slicesOverX);
  dy1 = floor(s1/slicesOverY)/slicesOverY;

  dx2 = fract(s2/slicesOverX);
  dy2 = floor(s2/slicesOverY)/slicesOverY;

  texpos1.x = dx1+(volpos.x/slicesOverX);
  texpos1.y = dy1+(volpos.y/slicesOverY);

  texpos2.x = dx2+(volpos.x/slicesOverX);
  texpos2.y = dy2+(volpos.y/slicesOverY);

  return mix( texture2D(uData,texpos1), texture2D(uData,texpos2), (volpos.z*numberOfSlices)-s1);
}

vec4 RGBToHSVv4( vec4 rgba ) { 
  vec4 return_value; 
  float v, x, f, i; 
  float R = rgba.r, G = rgba.g, B = rgba.b; 
  x = min(R, min( G, B ) ); 
  v = max(R, max( G, B ) ); 
  if(v == x) 
    return_value = vec4(0, 0, v, rgba.a); 
  else { 
    f = (R == x) ? G - B : ((G == x) ? B - R : R - G); 
    i = (R == x) ? 3.0 : ((G == x) ? 5.0 : 1.0); 
    return_value = vec4(i - f /(v - x), (v - x)/v, v, rgba.a); 
  } 
  return return_value; 
}

vec3 RGBToHSVv3( vec3 rgb ) {
  return RGBToHSVv4( vec4(rgb,1.0) ).rgb;
}

// convert from hsv to rgb 
vec4 HSVToRGBv4( vec4 hsva ) { 
  vec4 return_value; 
  float h = hsva.x, s = hsva.y, v = hsva.z, m, n, f; 
  float i; 
  if( h == 0.0 ) 
    return_value = vec4(v, v, v, hsva.a); 
  else { 
    i = floor(h); 
    f = h - i; 
    float t = i / 2.0; 
    if( t - floor( t ) >  0.1 ) 
      f = 1.0 - f; // if i is even 
    m = v * (1.0 - s); 
    n = v * (1.0 - s * f); 
    if( i == 6.0 || i == 0.0 ) return_value = vec4(v, n, m, hsva.a); 
    else if( i == 1.0 ) return_value = vec4(n, v, m, hsva.a); 
    else if( i == 2.0 ) return_value = vec4(m, v, n, hsva.a); 
    else if( i == 3.0 ) return_value = vec4(m, n, v, hsva.a); 
    else if( i == 4.0 ) return_value = vec4(n, m, v, hsva.a); 
    else if( i == 5.0 ) return_value = vec4(v, m, n, hsva.a); 
    // should never happen 
    else return_value = vec4( 0, 0, 0, 1 ); 
  }
  return return_value; 
}

vec3 HSVToRGBv3( vec3 hsv ) {
  return HSVToRGBv4( vec4(hsv,1.0) ).rgb;
}

vec4 normalizedNormalFromTexture(sampler2D normals, vec4 pos) {
  vec4 n = cTexture3D(normals, pos.xyz);
  n.xyz = (2.0*n.xyz)-1.0;
  n.a = length(n.xyz);
  if( length(n.xyz) > 0.001 )
    n.xyz = normalize(n.xyz);
  return n;
}

struct RayResult {
 vec4 color;
 vec4 zpoint;
};

// compute t such that r0+t*dir is the exit point of the [0,1] box
float rayexit(vec3 r0, vec3 dir) {
	vec3 q = 1.0/(dir+1.0e-6);
	vec3 t0 = -r0*q;
	vec3 tmax = max(t0,q+t0);
	return min(tmax.x,min(tmax.y,tmax.z));
}


// CartoonVolumeStyle
// Notes:
void CartoonVolumeStyle( inout vec4 current_color,
                         vec4 pos,
                         vec4 viewdir,
                         bool enabled,
                         vec3 parallelColorHSV,
                         vec3 orthogonalColorHSV,
                         int colorSteps,
                         vec4 normal ) {
  
  if( enabled && colorSteps >= 1 ) {
    if( normal.a > 0.001 ) {
      float cos_a = dot( normal.xyz, viewdir.xyz );
      if( cos_a < 0.0 ) {
        current_color.rgb = vec3( 0.0, 0.0, 0.0 );
      } else {
      
        float step = 1.0 / float(colorSteps);
        float interval = floor( cos_a / step );
        if( interval >= float(colorSteps) )
          interval = float(colorSteps) - 1.0;
        float w = interval * step;
        current_color.rgb = HSVToRGBv3( mix(orthogonalColorHSV,  parallelColorHSV,w));
        //HSVToRGB( orthogonalColorHSV * w + parallelColorHSV * (1.0-w) );
	
        // 2 -> 0-0.5-1           0.5
        // 3 -> 0-0.33-0.66-1     0.33
        // 4 -> 0-0.25-0.5-0.75-1 0.25
      }
    } else {
      current_color.a = 0.0;
    }
  }
  
}

// traverse ray
// Inputs:
//   r0  - ray start (xyz), ray exit time (w)
//   dir - ray direction (xyz), step length (-w)
// Output:
//   RayResult.color  - the computed RGBA color for this fragment
//   RayResult.zpoint - the point to use for depth calculations,
//                      if zpoint.x<0, no depth is computed
RayResult traverseRay(vec4 r0, vec4 dir) 
{
	//useful stuff (hopefully not computed if not needed...?)
	mat4 view_to_tex = textureMatrix*modelViewMatrixInverse;
	mat4 tex_to_view = modelViewMatrix*textureMatrixInverse;
	vec4 viewdir_tex = vec4( -normalize(dir.xyz), 0.0 );
	
	// return value
	RayResult rr;
	
	// initial color of this fragment is black with zero alpha
	rr.color = vec4(0.0, 0.0, 0.0, 0.0);
	// initial depth is not defined
	rr.zpoint = vec4(-1.0, 0.0, 0.0, 0.0);
	
	//BEGIN PRE-LOOP
	vec3 parallelColorHSV_4188f80 = RGBToHSVv3(parallelColor4188f80);
	vec3 orthogonalColorHSV_4188f80 = RGBToHSVv3(orthogonalColor4188f80);
	//END PRE-LOOP
	
	// compositing loop
	//while( rr.color.a<0.95 && r0.w>=0.0 ) 
	for (float rayIterator = 0.0; rayIterator < 10.0; rayIterator += 1.0)
	{	
		vec4 orig_sample_color = cTexture3D(uVolData, r0.xyz);

		orig_sample_color.a = orig_sample_color.r;

		vec4 sample_default_normal = normalizedNormalFromTexture( defaultNormals, r0 );

		//ORIG_SAMPLE_MANIP

		// color of this sample
		vec4 sample_color = orig_sample_color;  

		//BEGIN INSIDE-LOOP
		CartoonVolumeStyle(sample_color, r0, viewdir_tex, enabled4188f80, parallelColorHSV_4188f80, orthogonalColorHSV_4188f80, colorSteps4188f80, sample_default_normal);
		//END INSIDE-LOOP

		//BEGIN COMPOSITING
		// front-to-back compositing 
		sample_color.rgb *= sample_color.a; 
		rr.color += sample_color*(1.0-rr.color.a);
		if( rr.zpoint.x < 0.0 && rr.color.a > 0.0 ) { 
			rr.zpoint = vec4( r0.xyz, 1 ); 
		} 

		//END COMPOSITING

		// step forward along ray
		r0 += dir;
		
		if (!(rr.color.a<0.95 && r0.w>=0.0))
			break;
	}
	
	//BEGIN POST-LOOP
	//END POST-LOOP
	
	if( rr.color.a == 0.0 ) discard;
	
	// return result
	return rr;
}


void main()
{
	textureMatrix = mat4(1.000, 0.000, 0.000, 0.500, 0.000, 1.000, 0.000, 0.500, 0.000, 0.000, 1.000, 0.500, 0.000, 0.000, 0.000, 1.000);
	textureMatrixInverse = mat4(1.000, 0.000, 0.000, -0.500, 0.000, 1.000, 0.000, -0.500, 0.000, 0.000, 1.000, -0.500, 0.000,  0.000,  0.000,  1.000);
	
	// initialize ray
	vec4 raydir = vec4(normalize(rayDir), -1.0);
	float texit = rayexit(rayStart,raydir.xyz);
	raydir = rayStep*raydir;
	vec4 raypos = vec4(rayStart, texit);
	
	// traverse ray
	RayResult rr = traverseRay(raypos, raydir);

	// set color
	gl_FragColor= rr.color;
/*
	// set depth if computed
	if( rr.zpoint.x>=0.0 ) {
	  // set depth
	  vec4 tmp = modelViewProjectionMatrix*textureMatrixInverse*rr.zpoint;
	  // in window coordinates
	  gl_FragDepth = 0.5*(gl_DepthRange.diff*tmp.z/tmp.w + gl_DepthRange.near+gl_DepthRange.far);
	} else {
	  gl_FragDepth = gl_FragCoord.z;
	}	
*/	
}
       ]]>
       </ShaderPart>
     </ComposedShader>
</Appearance>


<IndexedFaceSet DEF='cube' solid='true' ccw='true' coordIndex='0, 1, 2, -1, 0, 2, 3, -1, 4, 5, 6, -1, 4, 6, 7, -1, 8, 9, 10, -1, 8, 10, 11, -1, 12, 13, 14, -1, 12, 14, 15, -1, 16, 17, 18, -1, 16, 18, 19, -1, 20, 21, 22, -1, 20, 22, 23' >
<Coordinate point='0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0,  1.0, 0.0, 0.0,  1.0, 1.0, 1.0,  1.0, 1.0, 1.0,  1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0'/>


<Color color='0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0'/> 

</IndexedFaceSet>
</Shape>
</Group>
</Scene>
</X3D>
   
  </body>
</html>

<!--
  Matrix4f S  = Matrix4f(1.0f/dim.x, 0.0, 0.0, 0.0,
                         0.0, 1.0f/dim.y, 0.0, 0.0,
                         0.0, 0.0, 1.0f/dim.z, 0.0, 
                         0.0, 0.0, 0.0, 1.0f);
  // center => [0, 1]
  Matrix4f  T  = Matrix4f(1.0, 0.0, 0.0, 0.5,
                          0.0, 1.0, 0.0, 0.5,
                          0.0, 0.0, 1.0, 0.5,
                          0.0, 0.0, 0.0, 1.0);
T*S
1.000 0.000 0.000 0.500
0.000 1.000 0.000 0.500
0.000 0.000 1.000 0.500
0.000 0.000 0.000 1.000

T*S inverse
1.000  0.000  0.000 -0.500
0.000  1.000  0.000 -0.500
0.000  0.000  1.000 -0.500
0.000  0.000  0.000  1.000			  
			  
-->
